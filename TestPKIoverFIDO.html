<!DOCTYPE html>
<html>

<head>
    <title>TestPKI Example</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ensure use of most common Unicode characters -->
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <!-- Considered an "experimental" feature -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css" />
    <!-- Spectre.css icons are used -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <script src="./MakeCredential Example_files/cbor.js"></script>
    <script src="./MakeCredential Example_files/helpers.js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-3776848-14');
    </script>
    <script>
        (function (d) {
            var wf = d.createElement('script'),
                s = d.scripts[0];
            wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js';
            wf.async = true;
            s.parentNode.insertBefore(wf, s);
        })(document);
    </script>
    <script src="./library/jquery.min.js"></script>
    <script src="./library/bootstrap.min.js" integrity="sha256-Tz+u7EaSlLYQ9sqCqhzCszaP1WYRsxxVHC7iJP6ttBE="
        crossorigin="anonymous"></script>
    <script async="" src="./library/bundle.js"></script>
    <script>
        function displayCert(strCertificate) {

            $('#certificate').text(strCertificate)
            window.setTimeout(function () {
                console.log("Timeout ... trigger decode");
                $("#decode .btn").click();
            }, 100);


        }

        $(document).ready(function () {

            var btnDecode = document.getElementById('decode');
            btnDecode.style.visibility = 'hidden';

            var ctrlErr = document.getElementById('upload-error');
            ctrlErr.style.visibility = 'hidden';

            var ctrlCert = document.getElementById('certificate');
            ctrlCert.style.visibility = 'hidden';
        });
    </script>
</head>

<body>
    <table style="height: 492px; width: 888px;">
        <tbody>
            <tr>
                <td style="width: 496px;"><img src="http://www.go-trust.com/download/idem_key/idem_key_on_pc.png"
                        alt="Idem Key " width="477" height="519" />&nbsp;&nbsp;</td>
                <td style="width: 329px;">
                    <h1 style="text-align: center;"></h1>
                    <h3 style="text-align: center;">A demo of operating PKI over FIDO2 on PC</h3>
                    <table style="height: 160px;" border="1" width="395">
                        <tbody>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by CKA_LABEL</p>

                                    <p>
                                        <form style="text-align: center;" id="use-label" onsubmit="return false">
                                            <input type="text" name="ckaLabel" placeholder="CKA_LABEL"
                                                style="width: 342px; height:41px">

                                        </form>
                                    </p>
                                    <form style="text-align: center;" id="search-ckalabel" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit"
                                            style="width: 162px; height:34px;background-color: #008CBA;">Read
                                            Certificate</button>
                                    </form>
                                    <p>
                                        <form style="text-align: center;" id="sign-byckalabel" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                        </form>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                    <p>
                                        <form style="text-align:center" id="use-index" onsubmit="return false">
                                            <input type="number" name="certIndex" placeholder="index"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>
                                    <form style="text-align: center;" id="find-index" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit"
                                            style="width: 162px; height:34px;background-color: #008CBA;">Read
                                            Certificate</button>
                                    </form>
                                    <p>
                                        <form style="text-align: center;" id="sign-byindex" onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                        </form>
                                    </p>
                                </td>
                            </tr>


                        </tbody>
                    </table>

                    <h3 style="text-align: center;">A demo of operating PKI over FIDO2 on Ａndroid</h3>
                    <table style="height: 160px;" border="1" width="395">
                        <tbody>

                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by CKA_LABEL</p>

                                    <p>
                                        <form style="text-align: center;" id="android-ckalabel-pin"
                                            onsubmit="return false">
                                            <input type="text" name="pin" placeholder="User PIN"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="android-label" onsubmit="return false">
                                            <input type="text" name="ckaLabel" placeholder="CKA_LABEL"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="android-ckalabel-getassertion"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                        </form>
                                    </p>
                                </td>
                            </tr>

                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by Index (1~8)</p>

                                    <p>
                                        <form style="text-align: center;" id="android-index-pin"
                                            onsubmit="return false">
                                            <input type="text" name="pin" placeholder="User PIN"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="android-index" onsubmit="return false">
                                            <input type="number" name="certIndex" placeholder="index"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="android-index-getassertion"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                        </form>
                                    </p>
                                </td>
                            </tr>


                        </tbody>
                    </table>
                </td>

                <td style="width: 329px;">
                    <h1 style="text-align: center;"></h1>
                    <h3 style="text-align: center;">A demo of operating PKI over FIDO2 on iOS/Mac with Safari</h3>
                    <table style="height: 160px;" border="1" width="395">
                        <tbody>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by CKA_LABEL</p>

                                    <p>
                                        <form style="text-align: center;" id="use-label-safari" onsubmit="return false">
                                            <input type="text" name="ckaLabel" placeholder="CKA_LABEL"
                                                style="width: 342px; height:41px">

                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="safari-pin-label" onsubmit="return false">
                                            <input type="text" name="pin" placeholder="User PIN"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>

                                    <form style="text-align: center;" id="search-ckalabel-safari"
                                        onsubmit="return false">
                                        <button class="btn btn-primary" action="submit"
                                            style="width: 162px; height:34px;background-color: #008CBA;">Read
                                            Certificate</button>
                                    </form>
                                    <p>
                                        <form style="text-align: center;" id="sign-ckalabel-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                        </form>
                                    </p>
                                </td>

                            </tr>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                    <p>
                                        <form style="text-align:center" id="use-index-safari" onsubmit="return false">
                                            <input type="number" name="certIndex" placeholder="index"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="safari-pin-index" onsubmit="return false">
                                            <input type="text" name="pin" placeholder="User PIN"
                                                style="width: 342px; height:41px">
                                        </form>
                                    </p>
                                    <p>
                                        <form style="text-align: center;" id="find-index-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                        </form>
                                    </p>

                                    <p>
                                        <form style="text-align: center;" id="sign-index-safari"
                                            onsubmit="return false">
                                            <button class="btn btn-primary" action="submit"
                                                style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                        </form>
                                    </p>
                                </td>
                            </tr>


                        </tbody>
                    </table>
                </td>



            </tr>
        </tbody>
    </table>

    <div>
        <textarea style="width:100%;height:150px;" id="show-sign">

	</textarea>
    </div>

    <!--  Laurence -->
    <div class="container mt-2">
        <div id="form" class="mt-2 mb-2">
            <div class="container">
                <div class="row">
                    <div class="col">
                        <div class="card">
                            <div class="card-body">
                                <div id="results" class="d-none mt-2"></div>
                                <form>
                                    <div class="form-group">
                                        <textarea class="form-control certificate" id="certificate" rows="8"
                                            style="white-space: pre" required="" autofocus=""></textarea>

                                        <div id="upload-error" class="alert alert-danger alert-dismissible mt-1"
                                            style="display: none;" role="alert">
                                            <small id="upload-error-message"></small>
                                            <button type="button" class="close" aria-label="Close"
                                                onclick="$(&#39;#upload-error&#39;).hide()">
                                                <span aria-hidden="true">×</span></button></div>
                                    </div>
                                    <div class="text-center">
                                        <div id="decode">
                                            <button id="decode" type="submit"
                                                class="btn btn-primary btn-lg">Decode</button>
                                        </div>
                                        <div id="error" class="alert alert-danger alert-dismissible mt-2"
                                            style="display: none;" role="alert">
                                            <span id="error-message"></span>
                                            <button type="button" class="close" aria-label="Close"
                                                onclick="$(&#39;#error&#39;).hide()">
                                                <span aria-hidden="true">×</span></button>
                                        </div>
                                    </div>

                                    <div id="cert-info-warn" class="alert alert-warning mt-3">
                                        <small>Certificate information will never leave your browser. Decoding happens
                                            using client-side JavaScript.</small>
                                    </div>
                                </form>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var GTheader = 'R29UcnVzdC1JZGVtLVBLSQ=='; // GoTrust-Idem-PKI
        // 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef  
        var signData =
            'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';
        //    1234567890abcdef1234567890abcdef
        var signShortData = 'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';


        document.getElementById('find-index').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index').certIndex.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Index'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Search_by_Index:', publicKey1)


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject)
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!')


                    const sliced = new Uint8Array(authData.credID.slice(1, authData.credID.length))
                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, sliced)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)

                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })
        document.getElementById('find-index-safari').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Index'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "userVerification": "discouraged",
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Search_by_Index on Safari:', bufToHex(publicKey1));


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject)
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!');


                    const sliced = new Uint8Array(authData.credID.slice(1, authData.credID.length))
                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, sliced)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)

                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })

        })
        document.getElementById('sign-byindex').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index').certIndex.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_buf = new Uint8Array(4);
            command_buf[0] = 0xDF;
            command_buf[1] = 0x02;
            command_buf[2] = 01;
            command_buf[3] = certIndex;

            var alg_buf = new Uint8Array(4);
            alg_buf[0] = 0xDF;
            alg_buf[1] = 0x03;
            alg_buf[2] = 01;
            alg_buf[3] = 0x02;

            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
            signDataBuf[0] = 0xDF;
            signDataBuf[1] = 0x06;
            signDataBuf[2] = signDataPayload.length;
            signDataBuf.set(signDataPayload, 3);


            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength + alg_buf
                .byteLength + signDataBuf.byteLength);
            var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + signDataBuf.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE3;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
            pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf.byteLength);
            pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                .byteLength + alg_buf.byteLength);

            console.log("sign-byindex", bufToHex(pki_buffer));
            var getAssertionChallenge = {
                'challenge': challenge,
            }
            var idList = [{
                id: pki_buffer,
                transports: ["usb", "nfc"],
                type: "public-key"
            }];

            getAssertionChallenge.allowCredentials = idList;
            console.log('List getAssertionChallenge', getAssertionChallenge)


            navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                })
                .then((newCredentialInfo) => {
                    alert('Sign finished!')
                    console.log('SUCCESS', newCredentialInfo);
                    console.log("Sign", newCredentialInfo.response.signature);

                    const sign = newCredentialInfo.response.signature;
                    var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                    document.getElementById('show-sign').value = "Data:" + "\n" + signData + "\n" +
                        "sign:" + "\n" + btoa(str);


                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('search-ckalabel').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;

            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Label'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('List publicKey1', publicKey1)


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject);
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!');

                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, authData.credID)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)




                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('search-ckalabel-safari').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;

            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Label'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "userVerification": "discouraged",
                    "authenticatorAttachment": "cross-platform",


                },
                'attestation': "none",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('search-ckalabel-safari', bufToHex(publicKey1));


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject);
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!');

                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, authData.credID)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)




                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('sign-byckalabel').addEventListener('submit', function (event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var alg_buf = new Uint8Array(4);
            alg_buf[0] = 0xDF;
            alg_buf[1] = 0x03;
            alg_buf[2] = 01;
            alg_buf[3] = 0x02;

            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
            signDataBuf[0] = 0xDF;
            signDataBuf[1] = 0x06;
            signDataBuf[2] = signDataPayload.length;
            signDataBuf.set(signDataPayload, 3);


            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength + alg_buf
                .byteLength + signDataBuf.byteLength);
            var pki_payload_length = command_bufer.byteLength + alg_buf.byteLength + signDataBuf.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE2;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + 3);
            pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_bufer
                .byteLength + alg_buf.byteLength);

            console.log(bufToHex(pki_buffer));


            var getAssertionChallenge = {
                'challenge': challenge,
            }
            var idList = [{
                id: pki_buffer,
                transports: ["usb", "nfc"],
                type: "public-key"
            }];

            getAssertionChallenge.allowCredentials = idList;
            console.log('List getAssertionChallenge', getAssertionChallenge)


            navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log("Sign", newCredentialInfo.response.signature)
                    const sign = newCredentialInfo.response.signature;
                    var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                    document.getElementById('show-sign').value = "Data:" + "\n" + signData + "\n" +
                        "sign:" + "\n" + btoa(str);

                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('android-ckalabel-getassertion').addEventListener('submit', function (event) {
            event.preventDefault();




            let ckaLabel = document.getElementById('android-label').ckaLabel.value;
            let userpin = document.getElementById('android-ckalabel-pin').pin.value;
            console.log('android-label', ckaLabel);
            console.log('android-ckalabel-pin', userpin);

            // var challenge = new Uint8Array(32);
            // window.crypto.getRandomValues(challenge);
            // var challenge = new Uint8Array(32);
            // var userID = 'Kosv9fPtkDoh4Oz7Yq/pVgWHS8HhdlCto5cR0aBoVMw='
            // var id = Uint8Array.from(window.atob(userID), c => c.charCodeAt(0));
            // var local_privateKey;
            // var local_privateKey;
            // var externalECPublicKey;
            // var exportECPublicKeyArray;
            // var pinEncKey;
            // var EncryptedPINArray;
            // var android_readecdh = {
            //     'challenge': challenge,

            //     'rp': {
            //         'name': 'GoTrustID Inc.',
            //     },

            //     'user': {
            //         'id': id,
            //         'name': 'alice@example.com',
            //         'displayName': 'Alice von Wunderland'
            //     },

            //     "authenticatorSelection": {
            //         "userVerification": "discouraged",
            //         "requireResidentKey": false,
            //         "authenticatorAttachment": "cross-platform"

            //     },
            //     'attestation': "direct",
            //     'pubKeyCredParams': [{
            //             'type': 'public-key',
            //             'alg': -7
            //         },
            //         {
            //             'type': 'public-key',
            //             'alg': -257
            //         }
            //     ]
            // }
            // console.log('android_readecdh', android_readecdh);

            // navigator.credentials.create({
            //     'publicKey': android_readecdh
            // }).then((newCredentialInfo) => {

            //     let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
            //     let authData = parseAuthData(attestationObject.authData);
            //     var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
            //     console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
            //     console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

            //     var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
            //     var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
            //     console.log("externalECPublicKeyX ", externalECPublicKeyX);
            //     console.log("externalECPublicKeyY", externalECPublicKeyY);

            //     return window.crypto.subtle.importKey(
            //         "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
            //         { //this is an example jwk key, other key types are Uint8Array objects
            //             kty: "EC",
            //             crv: "P-256",
            //             x: externalECPublicKeyX,
            //             y: externalECPublicKeyY,
            //             ext: true,
            //         }, { //these are the algorithm options
            //             name: "ECDH",
            //             namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
            //         },
            //         true, //whether the key is extractable (i.e. can be used in exportKey)
            //         [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
            //     );

            // }).then(function (external_public) {
            //     //returns a privateKey (or publicKey if you are importing a public key)
            //     externalECPublicKey = external_public;
            //     console.log("external_public", externalECPublicKey);
            //     return window.crypto.subtle.generateKey({
            //             name: "ECDH",
            //             namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
            //         },
            //         true, //whether the key is extractable (i.e. can be used in exportKey)
            //         ["deriveKey",
            //             "deriveBits"
            //         ] //can be any combination of "deriveKey" and "deriveBits"
            //     );
            // }).then(function (key) { //generate ecdh pair

            //     local_publicKey = key.publicKey;
            //     local_privateKey = key.privateKey;


            //     window.crypto.subtle.exportKey("raw", local_publicKey).then(
            //         function (keydata) {
            //             exportECPublicKeyArray = keydata;
            //             console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
            //         }
            //     );


            //     return window.crypto.subtle.deriveBits({
            //             name: "ECDH",
            //             namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
            //             public: externalECPublicKey, //an ECDH public key from generateKey or importKey

            //         },
            //         local_privateKey, //from generateKey or importKey above
            //         256 //the number of bits you want to derive
            //     );

            // }).then(function (keybits) { //convert share secret to pinEncKey
            //     return crypto.subtle.digest(
            //         "SHA-256",
            //         new Uint8Array(keybits)
            //     );
            // }).then(function (pinEncKeyBytes) {
            //     console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
            //     return crypto.subtle.importKey("raw",
            //         pinEncKeyBytes,
            //         "aes-cbc", false, ["encrypt"]);

            // }).then(function (importKey) {
            //     pinEncKey = importKey;
            //     console.log("pinEncKey ", pinEncKey);
            //     const encoder = new TextEncoder();
            //     const data = encoder.encode(userpin);
            //     return crypto.subtle.digest(
            //         "SHA-256",
            //         data);
            // }).then(function (userpin_digestBytes) {
            //     console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
            //     var iv = new Uint8Array(16);
            //     console.log("iv .... ", iv);

            //     return crypto.subtle.encrypt({
            //         name: "aes-cbc",
            //         iv
            //     }, pinEncKey, userpin_digestBytes.slice(0, 16));
            // }).then(function (cipherPIN) { // start get assertion

            //     EncryptedPINArray = cipherPIN.slice(0, 16);
            //     console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
            //     var enc = new TextEncoder();
            //     var pki_buffer = [];
            //     var challenge = new Uint8Array(32);
            //     window.crypto.getRandomValues(challenge);
            //     var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            //     var ckalabel_buffer = new Uint8Array(ckaLabel.length + 1);
            //     ckalabel_buffer[0] = ckaLabel.length;
            //     ckalabel_buffer.set(new Uint8Array(enc.encode(ckaLabel)), 1);
            //     var alg_buffer = new Uint8Array(1);
            //     alg_buffer[0] = 0x02 //RSA2048-sha256:2 

            //     var bSignData = Uint8Array.from(window.atob(signDataShortLength), c => c.charCodeAt(0));
            //     var signDataBuffer = new Uint8Array(bSignData.length + 1);
            //     signDataBuffer[0] = bSignData.length;
            //     signDataBuffer.set(new Uint8Array(bSignData), 1);

            //     var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + exportECPublicKeyArray
            //         .byteLength + EncryptedPINArray.byteLength +
            //         ckalabel_buffer.byteLength + alg_buffer.byteLength + signDataBuffer.byteLength);
            //     pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);

            //     pki_buffer.set(new Uint8Array(exportECPublicKeyArray), gtheaderbuffer.byteLength);

            //     pki_buffer.set(new Uint8Array(EncryptedPINArray), gtheaderbuffer.byteLength +
            //         exportECPublicKeyArray.byteLength);

            //     pki_buffer.set(new Uint8Array(ckalabel_buffer), gtheaderbuffer.byteLength +
            //         exportECPublicKeyArray.byteLength + EncryptedPINArray.byteLength);

            //     pki_buffer.set(new Uint8Array(alg_buffer), gtheaderbuffer.byteLength +
            //         exportECPublicKeyArray.byteLength + EncryptedPINArray.byteLength +
            //         ckalabel_buffer.byteLength);

            //     pki_buffer.set(new Uint8Array(signDataBuffer), gtheaderbuffer.byteLength +
            //         exportECPublicKeyArray.byteLength + EncryptedPINArray.byteLength +
            //         ckalabel_buffer.byteLength + alg_buffer.byteLength);
            //     console.log("6.pki_buffer:" + bufToHex(pki_buffer));

            //     var getAssertionChallenge = {
            //         'challenge': challenge,
            //         "userVerification": "discouraged"
            //     }
            //     var idList = [{
            //         id: pki_buffer,
            //         transports: ["usb", "nfc", "ble"],
            //         type: "public-key"
            //     }];

            //     getAssertionChallenge.allowCredentials = idList;
            //     console.log('List getAssertionChallenge', getAssertionChallenge)

            //     navigator.credentials.get({
            //             'publicKey': getAssertionChallenge
            //         })
            //         .then((newCredentialInfo) => {
            //             alert('Sign finished!')
            //             console.log('SUCCESS', newCredentialInfo)
            //             console.log("Sign", newCredentialInfo.response.signature)
            //             const sign = newCredentialInfo.response.signature;
            //             var str = String.fromCharCode.apply(null, new Uint8Array(sign));

            //             document.getElementById('show-sign').value = "Data:" + "\n" + signData +
            //                 "\n" +
            //                 "sign:" + "\n" + btoa(str);

            //         })
            //         .catch((error) => {
            //             alert(error)
            //             console.log('FAIL', error)
            //         })

            // });

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 3);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 3);



                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE4;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-android: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {

                    alert('Sign finished');
                    console.log('SUCCESS', newCredentialInfo)
                    console.log("Sign", newCredentialInfo.response.signature)
                    const sign = newCredentialInfo.response.signature;

                    if (sign.byteLength < 256) {
                        navigator.credentials.get({
                                'publicKey': getAssertionChallenge
                            }).then((newCredentialInfo) => {

                                alert('Sign finished');
                                console.log('SUCCESS', newCredentialInfo)
                                console.log("Sign", newCredentialInfo.response.signature)
                                const sign = newCredentialInfo.response.signature;
                                var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sign));

                                document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +
                                    "sign:" + "\n" + btoa(str);
                            })
                            .catch((error) => {
                                alert(error)
                                console.log('FAIL', error)
                   
                            })
                    }else{
                        document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +
                                    "sign:" + "\n" + btoa(str);
                    }

                });

            });
        })


        document.getElementById('android-index-getassertion').addEventListener('submit', function (event) {
            event.preventDefault();


            let certIndex = document.getElementById('android-index').certIndex.value;
            let userpin = document.getElementById('android-index-pin').pin.value;


            console.log('android-index', certIndex);
            console.log('android-index-pin', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(4);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 01;
                command_buf[3] = certIndex;

                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged",
                    'timeout': "2000",
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {

                    alert('Sign finished');
                    console.log('SUCCESS', newCredentialInfo)
                    console.log("Sign", newCredentialInfo.response.signature)
                    const sign1 = newCredentialInfo.response.signature;

                    var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sign1));
                        document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +"sign: " + str.byteLength+" bytes"
                                    "\n" + btoa(str);
                                    
                    if (sign1.byteLength < 256) {
                        navigator.credentials.get({
                                'publicKey': getAssertionChallenge
                            }).then((newCredentialInfo) => {

                                alert('Sign finished');
                                console.log('SUCCESS', newCredentialInfo)
                                console.log("Sign", newCredentialInfo.response.signature)
                                const sign2 = newCredentialInfo.response.signature;
                                var str2 = String.fromCharCode.apply(null, new Uint8Array(
                                    sign2));
                                var str1 = String.fromCharCode.apply(null, new Uint8Array(
                                    sign1));    

                                document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +
                                    "sign:" + "\n" + btoa(str1)+btoa(str2);
                            })
                            .catch((error) => {
                                alert(error)
                                console.log('FAIL', error)
                            })
                    }else{
                        var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sign1));
                        document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +
                                    "sign:" + "\n" + btoa(str);
                    }

                });

            });
        })




        document.getElementById('sign-index-safari').addEventListener('submit', function (event) {
            event.preventDefault();


            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            let userpin = document.getElementById('safari-pin-index').pin.value;


            console.log('use-index-safari', certIndex);
            console.log('safari-pin-index', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(4);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 01;
                command_buf[3] = certIndex;

                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {

                        console.log('SUCCESS', newCredentialInfo)
                        console.log("Sign", newCredentialInfo.response.signature)
                        const sign = newCredentialInfo.response.signature;
                        var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                        document.getElementById('show-sign').value = "Data:" + "\n" + signData +
                            "\n" +
                            "sign:" + "\n" + btoa(str);

                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })


        function base64EncodeURL(byteArray) {
            return btoa(Array.from(new Uint8Array(byteArray)).map(val => {
                return String.fromCharCode(val);
            }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        };

        function toUTF8Array(str) {

            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) utf8.push(charcode);
                else if (charcode < 0x800) {
                    utf8.push(0xc0 | (charcode >> 6),
                        0x80 | (charcode & 0x3f));
                } else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8.push(0xe0 | (charcode >> 12),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
                // surrogate pair
                else {
                    i++;
                    // UTF-16 encodes 0x10000-0x10FFFF by
                    // subtracting 0x10000 and splitting the
                    // 20 bits of 0x0-0xFFFFF into two halves
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10) |
                        (str.charCodeAt(i) & 0x3ff));
                    utf8.push(0xf0 | (charcode >> 18),
                        0x80 | ((charcode >> 12) & 0x3f),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
            }
            return utf8;
        }

        document.getElementById('sign-ckalabel-safari').addEventListener('submit', function (event) {
            event.preventDefault();


            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;
            let userpin = document.getElementById('safari-pin-label').pin.value;


            console.log('use-label-safari', ckaLabel);
            console.log('safari-pin-label', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                        'type': 'public-key',
                        'alg': -7
                    },
                    {
                        'type': 'public-key',
                        'alg': -257
                    }
                ]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function (external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function (key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function (keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function (keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function (pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function (importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function (userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function (cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 3);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 3);



                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {

                        alert('Sign finished');
                        console.log('SUCCESS', newCredentialInfo)
                        console.log("Sign", newCredentialInfo.response.signature)
                        const sign = newCredentialInfo.response.signature;
                        var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                        document.getElementById('show-sign').value = "Data:" + "\n" + signData +
                            "\n" +
                            "sign:" + "\n" + btoa(str);

                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })


        function base64EncodeURL(byteArray) {
            return btoa(Array.from(new Uint8Array(byteArray)).map(val => {
                return String.fromCharCode(val);
            }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        };

        function toUTF8Array(str) {

            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) utf8.push(charcode);
                else if (charcode < 0x800) {
                    utf8.push(0xc0 | (charcode >> 6),
                        0x80 | (charcode & 0x3f));
                } else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8.push(0xe0 | (charcode >> 12),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
                // surrogate pair
                else {
                    i++;
                    // UTF-16 encodes 0x10000-0x10FFFF by
                    // subtracting 0x10000 and splitting the
                    // 20 bits of 0x0-0xFFFFF into two halves
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10) |
                        (str.charCodeAt(i) & 0x3ff));
                    utf8.push(0xf0 | (charcode >> 18),
                        0x80 | ((charcode >> 12) & 0x3f),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
            }
            return utf8;
        }
    </script>

</body>

</html>